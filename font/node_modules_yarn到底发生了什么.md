### node_modules 那些与某些开发者不得不说的事情

> ***郑重声明: 本文仅仅代表个人的一些比较浅的理解, 如果有错误希望大家指出, 不要喷我。***

背景: yarn.lock,本文主要是由这个家伙开始的, 某月某日某项目代码线上出现了问题, 排查原因发现是因为lock文件被干掉了(不要问我问什么会被干掉 嘿嘿), 导致一些包默认升级了, 然后api 没有向下兼容 于是乎程序就挂了。 我直接指定包版本号不行吗, 原来真的不行。 哈哈 本文就带领你们剖析这一过程到底是怎样的。


问题前置: 好吧以下几个问题大家是否都清楚,然后就分析一手。

1. yarn 的时候到底发生了什么？

2. package.json 里面的配置说明?

3. yarn vs npm , yarn.lock?


### 1. 吹水篇

有人这样吐槽前端的开发者, 每天的工作不是在 yarn 就是在 yarn dev 然后 yarn build , 为什么会被叼 我在阳台上想了一个晚上，真相只有一个 那就是我们可以和ui妹子直接接触😁(玩笑玩笑), 但是事实上 确实就是与yarn 相关的一些命令确实会比较耗时。

> 要是你的项目就只是单纯的 html + js + css 什么依赖库都没有, 甚至都不需要打包压缩, 那就当我没说。

事实上随着 nodejs的出现 加快了前端工程化的演变, 目前的前端项目大多数都变成了`'src' + node_modules + other_package` 这个样子。

####  1.1 模块化的发展

- 函数分块
- AMD CMD 规范
- command.js

#### 1.2 node_modules 的设计

> 其实很多时候我们不关心过程, 我只要yarn的时候很快就能成功。 当然事实与预期不符合,然后就只看到命令行有个进度条好不容易快好的时候, 然后就卡在某个包那里, 然后仔细一看比较著名的代表就是: node-sass 嘿嘿, 当然了 如果网络不好, 你也会下载很长时间。难道我的这些包就不能像 golang 一样，早就把依赖下载到本地然后引用的时候就直接离线不行咩。这个与nodejs的包管理设计有关。 我仿佛听到有人说 deno 最后一段会稍微提一下哈哈。

- 难道我大前端 没有装依赖离线情况下就不能开发吗? 

当然了自建npm仓库也是可以规避这个问题的, 有没有发现npm的包体积还不小诶, 动不动几十几百兆的样子，想我一部电影也才几百兆(开车开车)





#### 1.3 yarn 的时候到底发生了什么


### 2. 摸鱼篇

#### 2.1 package.json 的配置

> 这里说明的是比较重要的: key-value

```json
{
  // 对外暴露的引用的地址 
  "main": "index.js",
  // 书写的类型
  "types": "index.d.ts",
  // 我们对项目工程触发的基础命令 dev start build
  "scripts": {},
  "license": "",
  "devDependencies": {},
  "dependencies": {},
  "peerDependencies": {},  
}
```



#### 你用的是 yarn 关我 npm 什么事,嗯,cnpm？



####  deno 


参考文章:
