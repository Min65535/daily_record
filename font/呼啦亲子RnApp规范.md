### 亲子RN 架构

- 待续

---

### 编码规范

- 前提参考: 前端相关的一些规范 [前端code规范](https://github.com/onionRunning/daily_record/blob/master/font/%E5%89%8D%E7%AB%AFcode%E8%A7%84%E8%8C%83.md)

---

1. check 组件的render次数, 避免非必要render, debugger-ui or 工具 一定要重视

```
关于这一点,其实可能web端体现不是很明显, 浏览器性能比较强大, 但是app端 是比较明显的, 需要重点注意⚠️
```

---

2. 一个文件, 只写一个组件， 避免额外组件进行干扰

```
文件尽量有主次, 一个文件下 有 n个组件 其实一眼看下去不直观, 不是很友好
```
---

3. 函数不要超过50行, 过长进行拆分

```
其实当你的函数超过30行的时候 其实就已经很长了, 不说单一原则吧, 尽可能减少函数代码行数, 是方便维护与理解
```

---

4. 与组件内部无关函数尽量提到外面,解耦组件内部函数相关逻辑

```
有些函数完全是与组件没啥关系的, 这种可以提取到 utils下， 或者提到组件外面, 然后这种函数测试的意义就比组件内部测试大
```

---


5. 组件的 style相关逻辑可以新建 index.style.ts 专门放置样式 (参考web端, css/js 分离)

```
ps. 本人是喜欢这样抽离处理, 如果涉及到样式与你的props/state 相关， 可以用函数的方式去编排, 相信你可以懂得， 在我看来 .tsx文件我更加倾向放 组件逻辑 或申明，或js逻辑， 常量，公共函数 放到 utils.ts 
```

---

6. 代码风格统一, react 都采用hook的方式书写, 老代码可以暂时忽略

```
这个不用说, hook的书写方式还是比较舒服的
```
---

7. 尽可能减少render 节点层级, 节点的层级过深, 是对ui会有些许影响的 (可以扁平)

```
web 端体现不明显， 其实在rn端层级过深 是会对渲染性能有一定的影响, js线程会被阻塞， 可能出现掉帧的情况
```
---

8. 后端返回的数据，需要进行兼容性判断

```
eg: 后端返回, res: {data: {medias: [{url: 'xxx'}]}}

我们用的时候就直接: res.data.medias[0].url, 这样非常容易造成崩溃, 不要太相信后端返回的数据类型以及xxx
需要这样处理: res?.data?.medias[0]?.url

```

9. 关于组件设计, 减少组件对外暴露的属性

```
一个组件应该是有特定的暴露属性, 不要搞太多,如果一下子看到组件的属性,就给人不直观的体现

<AXXssAAA
    click={xx}
    clickOpen={yy}
    xx={xy}
    isxx={xxx}
    isyy={yyy}
    data={xo}
    list={xu}
    config={kl}
    trans={ll}
>

ps. 组件对外交互的属性应该是我们思考好的， 尽量简洁易懂

```

- 关于帧率可以参考的文章, 如何优化卡顿的解决思路:

```
https://blog.csdn.net/ll1109489444/article/details/64437883?utm_source=blogxgwz5
```


- 待续

### git 规范

- 所有代码需要走pr, 然后最好是非本人才能merge

- 对于分支: dev(开发测试) -> master(正式分支)

- 对于commit 我们要尽可能按照规范来描述

### CI + CD 规范
